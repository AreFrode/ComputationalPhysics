<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Computational Physics:  Teach yourself C++">

<title>Computational Physics:  Teach yourself C++</title>

<!-- Bootstrap style: bootstrap -->
<link href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:50px;      /* fixed header height for style bootstrap */
  margin:-50px 0 0; /* negative fixed header height */
}
</style>


</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Getting Started, compiling and linking first',
               2,
               None,
               '___sec0'),
              ('Brief summary', 2, None, '___sec1'),
              ('From decimal to binary representation', 3, None, '___sec2'),
              ('Technical Matter in C/C++: Pointers', 2, None, '___sec3'),
              ('Using _strings_ instead of characters', 2, None, '___sec4'),
              ('Matrices in C++', 2, None, '___sec5'),
              ('"How to use the Library functions":"https://github.com/CompPhysics/ComputationalPhysicsMSU/tree/master/doc/Programs/LecturePrograms/programs/cppLibrary"',
               2,
               None,
               '___sec6'),
              ('"Using Armadillo to perform an LU decomposition":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/CppQtCodesLectures/MatrixTest/main.cpp"',
               2,
               None,
               '___sec7'),
              ('Optimization and profiling', 2, None, '___sec8'),
              ('Vectorization and the basic idea behind parallel computing',
               2,
               None,
               '___sec9'),
              ('What is vectorization?', 2, None, '___sec10'),
              ('"A simple test case with and without vectorization":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program7.cpp"',
               2,
               None,
               '___sec11'),
              ('Measuring performance', 2, None, '___sec12'),
              ('Problems with measuring time', 2, None, '___sec13'),
              ('Problems with cold start', 2, None, '___sec14'),
              ('Problems with smart compilers', 2, None, '___sec15'),
              ('Problems with interference', 2, None, '___sec16'),
              ('Problems with measuring performance', 2, None, '___sec17'),
              ('Thomas algorithm for tridiagonal linear algebra equations',
               2,
               None,
               '___sec18'),
              ('"The specialized Thomas algorithm (Project 1)":"https://github.com/CompPhysics/ComputationalPhysics/blob/master/doc/Projects/2016/Project1/Examples/TridiagonalTiming.cpp"',
               2,
               None,
               '___sec19'),
              ('"Example: Transpose of a matrix":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program8.cpp"',
               2,
               None,
               '___sec20'),
              ('"Matrix-matrix multiplication":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program9.cpp"',
               2,
               None,
               '___sec21'),
              ('How do we define speedup? Simplest form',
               2,
               None,
               '___sec22')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="learningcpp-bs.html">Computational Physics:  Teach yourself C++</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec0" style="font-size: 80%;"><b>Getting Started, compiling and linking first</b></a></li>
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec1" style="font-size: 80%;"><b>Brief summary</b></a></li>
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;From decimal to binary representation</a></li>
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec3" style="font-size: 80%;"><b>Technical Matter in C/C++: Pointers</b></a></li>
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec4" style="font-size: 80%;"><b>Using <b>strings</b> instead of characters</b></a></li>
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec5" style="font-size: 80%;"><b>Matrices in C++</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec6" style="font-size: 80%;"><b>"How to use the Library functions":"https://github.com/CompPhysics/ComputationalPhysicsMSU/tree/master/doc/Programs/LecturePrograms/programs/cppLibrary"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec7" style="font-size: 80%;"><b>"Using Armadillo to perform an LU decomposition":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/CppQtCodesLectures/MatrixTest/main.cpp"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec8" style="font-size: 80%;"><b>Optimization and profiling</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec9" style="font-size: 80%;"><b>Vectorization and the basic idea behind parallel computing</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec10" style="font-size: 80%;"><b>What is vectorization?</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec11" style="font-size: 80%;"><b>"A simple test case with and without vectorization":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program7.cpp"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec12" style="font-size: 80%;"><b>Measuring performance</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec13" style="font-size: 80%;"><b>Problems with measuring time</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec14" style="font-size: 80%;"><b>Problems with cold start</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec15" style="font-size: 80%;"><b>Problems with smart compilers</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec16" style="font-size: 80%;"><b>Problems with interference</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec17" style="font-size: 80%;"><b>Problems with measuring performance</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec18" style="font-size: 80%;"><b>Thomas algorithm for tridiagonal linear algebra equations</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec19" style="font-size: 80%;"><b>"The specialized Thomas algorithm (Project 1)":"https://github.com/CompPhysics/ComputationalPhysics/blob/master/doc/Projects/2016/Project1/Examples/TridiagonalTiming.cpp"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec20" style="font-size: 80%;"><b>"Example: Transpose of a matrix":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program8.cpp"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec21" style="font-size: 80%;"><b>"Matrix-matrix multiplication":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program9.cpp"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec22" style="font-size: 80%;"><b>How do we define speedup? Simplest form</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0001"></a>
<!-- !split -->

<h2 id="___sec6" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/tree/master/doc/Programs/LecturePrograms/programs/cppLibrary" target="_self">How to use the Library functions</a> </h2>

<p>
Standard C/C++: fetch the files <code>lib.cpp</code> and <code>lib.h</code>. You can make a directory where you store
these files, and eventually its compiled version lib.o. The example here is <a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/LinAlgebra/cpp/program1.cpp" target="_self">program1.cpp from chapter 6</a> and performs the matrix inversion.

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">//  Simple matrix inversion example</span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iostream&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;new&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cstdio&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cstdlib&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cmath&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cstring&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&quot;lib.h&quot;</span><span style="color: #BC7A00"></span>

<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span> std;

<span style="color: #408080; font-style: italic">/* function declarations */</span>

<span style="color: #B00040">void</span> <span style="color: #0000FF">inverse</span>(<span style="color: #B00040">double</span> <span style="color: #666666">**</span>, <span style="color: #B00040">int</span>);

<span style="color: #B00040">void</span> <span style="color: #0000FF">inverse</span>(<span style="color: #B00040">double</span> <span style="color: #666666">**</span>a, <span style="color: #B00040">int</span> n)
{
  <span style="color: #B00040">int</span>          i,j, <span style="color: #666666">*</span>indx;
  <span style="color: #B00040">double</span>       d, <span style="color: #666666">*</span>col, <span style="color: #666666">**</span>y;
  <span style="color: #408080; font-style: italic">// allocate space in memory</span>
  indx <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">int</span>[n];
  col  <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[n];
  y    <span style="color: #666666">=</span> (<span style="color: #B00040">double</span> <span style="color: #666666">**</span>) matrix(n, n, <span style="color: #008000; font-weight: bold">sizeof</span>(<span style="color: #B00040">double</span>));
  ludcmp(a, n, indx, <span style="color: #666666">&amp;</span>d);   <span style="color: #408080; font-style: italic">// LU decompose  a[][]</span>
  printf(<span style="color: #BA2121">&quot;</span><span style="color: #BB6622; font-weight: bold">\n\n</span><span style="color: #BA2121">LU form of matrix of a[][]:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>);
  <span style="color: #008000; font-weight: bold">for</span>(i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
    printf(<span style="color: #BA2121">&quot;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>);
    <span style="color: #008000; font-weight: bold">for</span>(j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
      printf(<span style="color: #BA2121">&quot; a[%2d][%2d] = %12.4E&quot;</span>,i, j, a[i][j]);
  <span style="color: #408080; font-style: italic">// find inverse of a[][] by columns</span>
  <span style="color: #008000; font-weight: bold">for</span>(j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
    <span style="color: #408080; font-style: italic">// initialize right-side of linear equations</span>
    <span style="color: #008000; font-weight: bold">for</span>(i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) col[i] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
    col[j] <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>;
    lubksb(a, n, indx, col);
    <span style="color: #408080; font-style: italic">// save result in y[][]</span>
    <span style="color: #008000; font-weight: bold">for</span>(i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) y[i][j] <span style="color: #666666">=</span> col[i];
  }   <span style="color: #408080; font-style: italic">//j-loop over columns</span>
  <span style="color: #408080; font-style: italic">// return the inverse matrix in a[][]</span>
  <span style="color: #008000; font-weight: bold">for</span>(i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
    <span style="color: #008000; font-weight: bold">for</span>(j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) a[i][j] <span style="color: #666666">=</span> y[i][j];

  free_matrix((<span style="color: #B00040">void</span> <span style="color: #666666">**</span>) y);     <span style="color: #408080; font-style: italic">// release local memory</span>
  <span style="color: #008000; font-weight: bold">delete</span> [] col;
  <span style="color: #008000; font-weight: bold">delete</span> []indx;
}  <span style="color: #408080; font-style: italic">// End: function inverse()</span>
</pre></div>

<h2 id="___sec7" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/CppQtCodesLectures/MatrixTest/main.cpp" target="_self">Using Armadillo to perform an LU decomposition</a> </h2>
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iostream&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&quot;armadillo&quot;</span><span style="color: #BC7A00"></span>
<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span> arma;
<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span> std;

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
  {
   mat A <span style="color: #666666">=</span> randu<span style="color: #666666">&lt;</span>mat<span style="color: #666666">&gt;</span>(<span style="color: #666666">5</span>,<span style="color: #666666">5</span>);
   vec b <span style="color: #666666">=</span> randu<span style="color: #666666">&lt;</span>vec<span style="color: #666666">&gt;</span>(<span style="color: #666666">5</span>);

  A.print(<span style="color: #BA2121">&quot;A =&quot;</span>);
  b.print(<span style="color: #BA2121">&quot;b=&quot;</span>);
  <span style="color: #408080; font-style: italic">// solve Ax = b</span>
  vec x <span style="color: #666666">=</span> solve(A,b);
  <span style="color: #408080; font-style: italic">// print x</span>
  x.print(<span style="color: #BA2121">&quot;x=&quot;</span>);
  <span style="color: #408080; font-style: italic">// find LU decomp of A, if needed, P is the permutation matrix</span>
  mat L, U;
  lu(L,U,A);
  <span style="color: #408080; font-style: italic">// print l</span>
  L.print(<span style="color: #BA2121">&quot; L= &quot;</span>);
  <span style="color: #408080; font-style: italic">// print U</span>
  U.print(<span style="color: #BA2121">&quot; U= &quot;</span>);
  <span style="color: #408080; font-style: italic">//Check that A = LU</span>
  (A<span style="color: #666666">-</span>P<span style="color: #666666">*</span>L<span style="color: #666666">*</span>U).print(<span style="color: #BA2121">&quot;Test of LU decomposition&quot;</span>);
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
  }
</pre></div>

<h2 id="___sec8" class="anchor">Optimization and profiling </h2>

<p>
Till now we have not paid much attention to speed and possible optimization possibilities
inherent in the various compilers. We have compiled and linked as
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>c  mycode.cpp
c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>o  mycode.exe  mycode.o
</pre></div>
<p>
For Fortran replace with for example <b>gfortran</b> or <b>ifort</b>.
This is what we call a flat compiler option and should be used when we develop the code.
It produces normally a very large and slow code when translated to machine instructions.
We use this option for debugging and for establishing the correct program output because
every operation is done precisely as the user specified it.

<p>
It is instructive to look up the compiler manual for further instructions by writing
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>man c<span style="color: #666666">++</span>
</pre></div>
<p>
We have additional compiler options for optimization. These may include procedure inlining where 
performance may be improved, moving constants inside loops outside the loop, 
identify potential parallelism, include automatic vectorization or replace a division with a reciprocal
and a multiplication if this speeds up the code.
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>c  mycode.cpp
c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>o  mycode.exe  mycode.o
</pre></div>
<p>
This (other options are -O2 or -Ofast) is the recommended option.

<p>
It is also useful to profile your program under the development stage.
You would then compile with 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>pg <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>c  mycode.cpp
c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>pg <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>o  mycode.exe  mycode.o
</pre></div>
<p>
After you have run the code you can obtain the profiling information via
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>gprof mycode.exe <span style="color: #666666">&gt;</span>  ProfileOutput
</pre></div>
<p>
When you have profiled properly your code, you must take out this option as it 
slows down performance.
For memory tests use <a href="http://www.valgrind.org" target="_self">valgrind</a>. An excellent environment for all these aspects, and much  more, is  Qt creator.

<p>
Adding debugging options is a very useful alternative under the development stage of a program.
You would then compile with 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>g <span style="color: #666666">-</span>O0 <span style="color: #666666">-</span>c  mycode.cpp
c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>g <span style="color: #666666">-</span>O0 <span style="color: #666666">-</span>o  mycode.exe  mycode.o
</pre></div>
<p>
This option generates debugging information allowing you to trace for example if an array is properly allocated. Some compilers work best with the no optimization option <b>-O0</b>.

<p>
Depending on the compiler, one can add flags which generate code that catches integer overflow errors. 
The flag <b>-ftrapv</b> does this for the CLANG compiler on OS X operating systems.

<p>
In general, irrespective of compiler options, it is useful to

<ul>
<li> avoid if tests or call to functions inside loops, if possible.</li> 
<li> avoid multiplication with constants inside loops if possible</li>
</ul>

Here is an example of a part of a program where specific operations lead to a slower code
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>k <span style="color: #666666">=</span> n<span style="color: #666666">-1</span>;
<span style="color: #008000; font-weight: bold">for</span> (i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>){
    a[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span>c<span style="color: #666666">*</span>d;
    e <span style="color: #666666">=</span> g[k];
}
</pre></div>
<p>
A better code is
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>temp <span style="color: #666666">=</span> c<span style="color: #666666">*</span>d;
<span style="color: #008000; font-weight: bold">for</span> (i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>){
    a[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span> temp;
}
e <span style="color: #666666">=</span> g[n<span style="color: #666666">-1</span>];
</pre></div>
<p>
Here we avoid a repeated multiplication inside a loop. 
Most compilers, depending on compiler flags, identify and optimize such bottlenecks on their own, without requiring any particular action by the programmer. However, it is always useful to single out and avoid code examples like the first one discussed here.

<h2 id="___sec9" class="anchor">Vectorization and the basic idea behind parallel computing </h2>

<p>
Present CPUs are highly parallel processors with varying levels of parallelism. The typical situation can be described via the following three statements.

<ul>
<li> Pursuit of shorter computation time and larger simulation size gives rise to parallel computing.</li>
<li> Multiple processors are involved to solve a global problem.</li>
<li> The essence is to divide the entire computation evenly among collaborative processors.  Divide and conquer.</li>
</ul>

Before we proceed with a more detailed discussion of topics like vectorization and parallelization, we need to remind ourselves about some basic features of different hardware models. We have

<ul>
<li> Conventional single-processor computers are named SISD (single-instruction-single-data) machines.</li>
<li> SIMD (single-instruction-multiple-data) machines incorporate the idea of parallel processing, using a large number of processing units to execute the same instruction on different data.</li>
<li> Modern parallel computers are so-called MIMD (multiple-instruction-multiple-data) machines and can execute different instruction streams in parallel on different data.</li>
</ul>

<h2 id="___sec10" class="anchor">What is vectorization? </h2>

<p>
Vectorization is a special
case of <b>Single Instructions Multiple Data</b> (SIMD) to denote a single
instruction stream capable of operating on multiple data elements in
parallel. 
We can think of vectorization as the unrolling of loops accompanied with SIMD instructions.

<p>
Vectorization is the process of converting an algorithm that performs scalar operations
(typically one operation at the time) to vector operations where a single operation can refer to many simultaneous operations.
Consider the following example
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">for</span> (i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>){
    a[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span> c[i];
}
</pre></div>
<p>
If the code is not vectorized, the compiler will simply start with the first element and 
then perform subsequent additions operating on one address in memory at the time.

<p>
A SIMD instruction can operate  on multiple data elements in one single instruction.
It uses the so-called 128-bit SIMD floating-point register. 
In this sense,vectorization adds some form of parallelism since one instruction is applied  
to many parts of say a vector.

<p>
The number of elements which can be operated on in parallel
range from four single-precision floating point data elements in so-called 
Streaming SIMD Extensions and two double-precision floating-point data
elements in Streaming SIMD Extensions 2 to sixteen byte operations in
a 128-bit register in Streaming SIMD Extensions 2. Thus, vector-length
ranges from 2 to 16, depending on the instruction extensions used and
on the data type.

<p>
We start with the simple scalar operations given by
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">for</span> (i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>){
    a[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span> c[i];
}
</pre></div>
<p>
If the code is not vectorized  and we have a 128-bit register to store a 32 bits floating point number,
it means that we have \( 3\times 32 \) bits that are not used. For the first element we have

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>  0  </b></td> <td align="center"><b>   1    </b></td> <td align="center"><b>   2    </b></td> <td align="center"><b>   3    </b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   a[0]=    </td> <td align="center">   not used    </td> <td align="center">   not used    </td> <td align="center">   not used    </td> </tr>
<tr><td align="center">   b[0]+    </td> <td align="center">   not used    </td> <td align="center">   not used    </td> <td align="center">   not used    </td> </tr>
<tr><td align="center">   c[0]     </td> <td align="center">   not used    </td> <td align="center">   not used    </td> <td align="center">   not used    </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-3 -->
</div> <!-- cell row -->
<p>
We have thus unused space in our SIMD registers. These registers could hold three additional integers.

<p>
If we vectorize the code, we can perform, with a 128-bit register four simultaneous operations, that is
we have
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">for</span> (i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">+=4</span>){
    a[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span> c[i];
    a[i<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> b[i<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> c[i<span style="color: #666666">+1</span>];
    a[i<span style="color: #666666">+2</span>] <span style="color: #666666">=</span> b[i<span style="color: #666666">+2</span>] <span style="color: #666666">+</span> c[i<span style="color: #666666">+2</span>];
    a[i<span style="color: #666666">+3</span>] <span style="color: #666666">=</span> b[i<span style="color: #666666">+3</span>] <span style="color: #666666">+</span> c[i<span style="color: #666666">+3</span>];
}
</pre></div>
<p>
displayed here as

<p>

<div class="row">
  <div class="col-xs-2">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>  0  </b></td> <td align="center"><b>  1  </b></td> <td align="center"><b>  2  </b></td> <td align="center"><b>  3  </b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   a[0]=    </td> <td align="center">   a[1]=    </td> <td align="center">   a[2]=    </td> <td align="center">   a[3]=    </td> </tr>
<tr><td align="center">   b[0]+    </td> <td align="center">   b[1]+    </td> <td align="center">   b[2]+    </td> <td align="center">   b[3]+    </td> </tr>
<tr><td align="center">   c[0]     </td> <td align="center">   c[1]     </td> <td align="center">   c[2]     </td> <td align="center">   c[3]     </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-2 -->
</div> <!-- cell row -->
Four additions are now done in a single step.

<h2 id="___sec11" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program7.cpp" target="_self">A simple test case with and without vectorization</a> </h2>
We implement these operations in a simple c++ program as

<p>

<!-- code=text (!bc cppcode) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &quot;time.h&quot; 

using namespace std; // note use of namespace                                       
int main (int argc, char* argv[])
{
  int i = atoi(argv[1]); 
  double *a, *b, *c;
  a = new double[i]; 
  b = new double[i]; 
  c = new double[i]; 
  for (int j = 0; j &lt; i; j++) {
    a[j] = 0.0;
    b[j] = cos(j*1.0);
    c[j] = sin(j*3.0);
  }
  clock_t start, finish;
  start = clock();
  for (int j = 0; j &lt; i; j++) {
    a[j] = b[j]+b[j]*c[j];
  }
  finish = clock();
  double timeused = (double) (finish - start)/(CLOCKS_PER_SEC );
  cout &lt;&lt; setiosflags(ios::showpoint | ios::uppercase);
  cout &lt;&lt; setprecision(10) &lt;&lt; setw(20) &lt;&lt; &quot;Time used  for vector addition and multiplication=&quot; &lt;&lt; timeused  &lt;&lt; endl;
  delete [] a;
  delete [] b;
  delete [] c;
  return 0;     
}
</pre></div>
<p>
We can compile and link without vectorization
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span> <span style="color: #666666">-</span>o novec.x vecexample.cpp
</pre></div>
<p>
vand with vectorization (and additional optimizations)
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span> <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>o  vec.x vecexample.cpp 
</pre></div>
<p>
The speedup depends on the size of the vectors. In the example here we have run with \( 10^7 \) elements.
The example here was run on a PC with ubuntu 14.04 as operating system and an Intel i7-4790 CPU running at 3.60 GHz. 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>vec.x <span style="color: #666666">10000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> vector addition <span style="color: #666666">=</span> <span style="color: #666666">0.0100000</span>
<span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>novec.x <span style="color: #666666">10000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> vector addition <span style="color: #666666">=</span> <span style="color: #666666">0.03000000000</span>
</pre></div>
<p>
This particular C++ compiler speeds up the above loop operations with a factor of 3. 
Performing the same operations for \( 10^8 \) elements results only in a factor \( 1.4 \).
The result will however vary from compiler to compiler. In general however, with optimization flags like \( -O3 \) or \( -Ofast \), we gain a considerable speedup if our code can be vectorized. Many of these operations can be done automatically by your compiler. These automatic or near automatic compiler techniques improve performance considerably.

<p>
Not all loops can be vectorized, as discussed in <a href="https://software.intel.com/en-us/articles/a-guide-to-auto-vectorization-with-intel-c-compilers" target="_self">Intel's guide to vectorization</a>

<p>
An important criteria is that the loop counter \( n \) is known at the entry of the loop.
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
    a[j] <span style="color: #666666">=</span> cos(j<span style="color: #666666">*1.0</span>);
  }
</pre></div>
<p>
The variable \( n \) does need to be known at compile time. However, this variable must stay the same for the entire duration of the loop. It implies that an exit statement inside the loop cannot be data dependent.

<p>
An exit statement should in general be avoided. 
If the exit statement contains data-dependent conditions, the loop cannot be vectorized. 
The following is an example of a non-vectorizable loop
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
    a[j] <span style="color: #666666">=</span> cos(j<span style="color: #666666">*1.0</span>);
    <span style="color: #008000; font-weight: bold">if</span> (a[j] <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span> ) <span style="color: #008000; font-weight: bold">break</span>;
  }
</pre></div>
<p>
Avoid loop termination conditions and opt for a single entry loop variable \( n \). The lower and upper bounds have to be kept fixed within the loop.

<p>
SIMD instructions perform the same type of operations multiple times. 
A <b>switch</b> statement leads thus to a non-vectorizable loop since different statemens cannot branch.
The following code can however be vectorized since the <b>if</b> statement is implemented as a masked assignment.
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
    <span style="color: #B00040">double</span> x  <span style="color: #666666">=</span> cos(j<span style="color: #666666">*1.0</span>);
    <span style="color: #008000; font-weight: bold">if</span> (x <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span> ) {
       a[j] <span style="color: #666666">=</span>  x<span style="color: #666666">*</span>sin(j<span style="color: #666666">*2.0</span>); 
    }
    <span style="color: #008000; font-weight: bold">else</span> {
       a[j] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
    }
  }
</pre></div>
<p>
These operations can be performed for all data elements but only those elements which the mask evaluates as true are stored. In general, one should avoid branches such as <b>switch</b>, <b>go to</b>, or <b>return</b> statements or <b>if</b> constructs that cannot be treated as masked assignments.

<p>
Only the innermost loop of the following example is vectorized
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
      <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
           a[i][j] <span style="color: #666666">+=</span> b[i][j];
      }  
  }
</pre></div>
<p>
The exception is if an original outer loop is transformed into an inner loop as the result of compiler optimizations.

<p>
Calls to programmer defined functions ruin vectorization. However, calls to intrinsic functions like
\( \sin{x} \), \( \cos{x} \), \( \exp{x} \) etc are allowed since they are normally efficiently vectorized. 
The following example is fully vectorizable
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
      a[i] <span style="color: #666666">=</span> log10(i)<span style="color: #666666">*</span>cos(i);
  }
</pre></div>
<p>
Similarly, <b>inline</b> functions defined by the programmer, allow for vectorization since the function statements are glued into the actual place where the function is called.

<p>
One has to keep in mind that vectorization changes the order of operations inside a loop. A so-called
read-after-write statement with an explicit flow dependency cannot be vectorized. The following code
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #B00040">double</span> b <span style="color: #666666">=</span> <span style="color: #666666">15.</span>;
  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">1</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
      a[i] <span style="color: #666666">=</span> a[i<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> b;
  }
</pre></div>
<p>
is an example of flow dependency and results in wrong numerical results if vectorized. For a scalar operation, the value \( a[i-1] \) computed during the iteration is loaded into the right-hand side and the results are fine. In vector mode however, with a vector length of four, the values \( a[0] \), \( a[1] \), \( a[2] \) and \( a[3] \) from the previous loop will be loaded into the right-hand side and produce wrong results. That is, we have
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>   a[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> a[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> b;
   a[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> a[<span style="color: #666666">1</span>] <span style="color: #666666">+</span> b;
   a[<span style="color: #666666">3</span>] <span style="color: #666666">=</span> a[<span style="color: #666666">2</span>] <span style="color: #666666">+</span> b;
   a[<span style="color: #666666">4</span>] <span style="color: #666666">=</span> a[<span style="color: #666666">3</span>] <span style="color: #666666">+</span> b;
</pre></div>
<p>
and if the two first iterations are  executed at the same by the SIMD instruction, the value of say \( a[1] \) could be used by the second iteration before it has been calculated by the first iteration, leading thereby to wrong results.

<p>
On the other hand,  a so-called 
write-after-read statement can be vectorized. The following code
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #B00040">double</span> b <span style="color: #666666">=</span> <span style="color: #666666">15.</span>;
  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">1</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
      a[i<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> a[i] <span style="color: #666666">+</span> b;
  }
</pre></div>
<p>
is an example of flow dependency that can be vectorized since no iteration with a higher value of \( i \)
can complete before an iteration with a lower value of \( i \). However, such code leads to problems with parallelization.

<p>
For C++ programmers  it is also worth keeping in mind that an array notation is preferred to the more compact use of pointers to access array elements. The compiler can often not tell if it is safe to vectorize the code.

<p>
When dealing with arrays, you should also avoid memory stride, since this slows down considerably vectorization. When you access array element, write for example the inner loop to vectorize using unit stride, that is, access successively the next array element in memory, as shown here
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
      <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
           a[i][j] <span style="color: #666666">+=</span> b[i][j];
      }  
  }
</pre></div>
<p>
We can compile and link without vectorization using the clang c++ (on OSX for example) compiler
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang <span style="color: #666666">-</span>o novec.x vecexample.cpp
</pre></div>
<p>
and with vectorization (and additional optimizations)
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang<span style="color: #666666">++</span> <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>Rpass<span style="color: #666666">=</span>loop<span style="color: #666666">-</span>vectorize <span style="color: #666666">-</span>o  vec.x vecexample.cpp 
</pre></div>
<p>
The speedup depends on the size of the vectors. In the example here we have run with \( 10^7 \) elements.
The example here was run on an IMac17.1 with OSX El Capitan (10.11.4) as operating system and an Intel i5 3.3 GHz CPU.

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>vec.x <span style="color: #666666">10000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> norm computation<span style="color: #666666">=0.04720500000</span>
<span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>novec.x <span style="color: #666666">10000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> norm computation<span style="color: #666666">=0.03311700000</span>
</pre></div>
<p>
This particular C++ compiler speeds up the above loop operations with a factor of 1.5 
Performing the same operations for \( 10^9 \) elements results in a smaller speedup since reading from main memory is required. The non-vectorized code is seemingly faster. 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>vec.x <span style="color: #666666">1000000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> norm computation<span style="color: #666666">=58.41391100</span>
<span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>novec.x <span style="color: #666666">1000000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> norm computation<span style="color: #666666">=46.51295300</span>
</pre></div>
<p>
We will discuss these issues below.

<p>
We can compile and link without vectorization with clang compiler
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang<span style="color: #666666">++</span> <span style="color: #666666">-</span>o <span style="color: #666666">-</span>fno<span style="color: #666666">-</span>vectorize novec.x vecexample.cpp
</pre></div>
<p>
and with vectorization
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang<span style="color: #666666">++</span> <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>Rpass<span style="color: #666666">=</span>loop<span style="color: #666666">-</span>vectorize <span style="color: #666666">-</span>o  vec.x vecexample.cpp 
</pre></div>
<p>
We can also add vectorization analysis, see for example
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang<span style="color: #666666">++</span> <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>Rpass<span style="color: #666666">-</span>analysis<span style="color: #666666">=</span>loop<span style="color: #666666">-</span>vectorize <span style="color: #666666">-</span>o  vec.x vecexample.cpp 
</pre></div>
<p>
or figure out if vectorization was missed
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang<span style="color: #666666">++</span> <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>Rpass<span style="color: #666666">-</span>missed<span style="color: #666666">=</span>loop<span style="color: #666666">-</span>vectorize <span style="color: #666666">-</span>o  vec.x vecexample.cpp 
</pre></div>

<h2 id="___sec12" class="anchor">Measuring performance </h2>

<p>
How do we measure erformance? What is wrong with this code to time a loop?
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  clock_t start, finish;
  start = clock();
  for (int j = 0; j &lt; i; j++) {
    a[j] = b[j]+b[j]*c[j];
  }
  finish = clock();
  double timeused = (double) (finish - start)/(CLOCKS_PER_SEC );
</pre></div>

<h2 id="___sec13" class="anchor">Problems with measuring time </h2>

<ol>
<li> Timers are not infinitely accurate</li>
<li> All clocks have a granularity, the minimum time that they can measure</li>
<li> The error in a time measurement, even if everything is perfect, may be the size of this granularity (sometimes called a clock tick)</li>
<li> Always know what your clock granularity is</li>
<li> Ensure that your measurement is for a long enough duration (say 100 times the <b>tick</b>)</li>
</ol>

<h2 id="___sec14" class="anchor">Problems with cold start </h2>

<p>
What happens when the code is executed? The assumption is that the code is ready to
execute. But

<ol>
<li> Code may still be on disk, and not even read into memory.</li>
<li> Data may be in slow memory rather than fast (which may be wrong or right for what you are measuring)</li>
<li> Multiple tests often necessary to ensure that cold start effects are not present</li>
<li> Special effort often required to ensure data in the intended part of the memory hierarchy.</li>
</ol>

<h2 id="___sec15" class="anchor">Problems with smart compilers </h2>

<ol>
<li> If the result of the computation is not used, the compiler may eliminate the code</li>
<li> Performance will look impossibly fantastic</li>
<li> Even worse, eliminate some of the code so the performance looks plausible</li>
<li> Ensure that the results are (or may be) used.</li>
</ol>

<h2 id="___sec16" class="anchor">Problems with interference </h2>

<ol>
<li> Other activities are sharing your processor</li>

<ul>
  <li> Operating system, system demons, other users</li>

<ul>
   <li> Some parts of the hardware do not always perform with exactly the same performance</li>
</ul>

</ul>

<li> Make multiple tests and report</li>
<li> Easy choices include</li>

<ul>
  <li> Average tests represent what users might observe over time</li>
</ul>

</ol>

<h2 id="___sec17" class="anchor">Problems with measuring performance  </h2>

<ol>
<li> Accurate, reproducible performance measurement is hard</li>
<li> Think carefully about your experiment:</li>
<li> What is it, precisely, that you want to measure</li>
<li> How representative is your test to the situation that you are trying to measure?</li>
</ol>

<h2 id="___sec18" class="anchor">Thomas algorithm for tridiagonal linear algebra equations </h2>
$$
\left( \begin{array}{ccccc}
        b_0 & c_0 &        &         &         \\
	a_0 &  b_1 &  c_1    &         &         \\
	   &    & \ddots  &         &         \\
	      &	    & a_{m-3} & b_{m-2} & c_{m-2} \\
	         &    &         & a_{m-2} & b_{m-1}
   \end{array} \right)
\left( \begin{array}{c}
       x_0     \\
       x_1     \\
       \vdots  \\
       x_{m-2} \\
       x_{m-1}
   \end{array} \right)=\left( \begin{array}{c}
       f_0     \\
       f_1     \\
       \vdots  \\
       f_{m-2} \\
       f_{m-1} \\
   \end{array} \right)
$$

<p>
The first step is to multiply the first row by \( a_0/b_0 \) and subtract it from the second row.  This is known as the forward substitution step. We obtain then
$$
	a_i = 0,
$$


$$                                 
	b_i = b_i - \frac{a_{i-1}}{b_{i-1}}c_{i-1},
$$

and
$$
	f_i = f_i - \frac{a_{i-1}}{b_{i-1}}f_{i-1}.
$$

At this point the simplified equation, with only an upper triangular matrix takes the form
$$
\left( \begin{array}{ccccc}
    b_0 & c_0 &        &         &         \\
       & b_1 &  c_1    &         &         \\
          &    & \ddots &         &         \\
	     &     &        & b_{m-2} & c_{m-2} \\
	        &    &        &         & b_{m-1}
   \end{array} \right)\left( \begin{array}{c}
       x_0     \\
       x_1     \\
       \vdots  \\
       x_{m-2} \\
       x_{m-1}
   \end{array} \right)=\left( \begin{array}{c}
       f_0     \\
       f_1     \\
       \vdots  \\
       f_{m-2} \\
       f_{m-1} \\
   \end{array} \right)
$$

<p>
The next step is  the backward substitution step.  The last row is multiplied by \( c_{N-3}/b_{N-2} \) and subtracted from the second to last row, thus eliminating \( c_{N-3} \) from the last row.  The general backward substitution procedure is 
$$
	c_i = 0, 
$$

and 
$$
	f_{i-1} = f_{i-1} - \frac{c_{i-1}}{b_i}f_i
$$

All that remains to be computed is the solution, which is the very straight forward process of
$$
x_i = \frac{f_i}{b_i}
$$

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>   Operation   </b></td> <td align="center"><b>Floating Point</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   Memory Reads       </td> <td align="center">   \( 14(N-2) \)     </td> </tr>
<tr><td align="center">   Memory Writes      </td> <td align="center">   \( 4(N-2) \)      </td> </tr>
<tr><td align="center">   Subtractions       </td> <td align="center">   \( 3(N-2) \)      </td> </tr>
<tr><td align="center">   Multiplications    </td> <td align="center">   \( 3(N-2) \)      </td> </tr>
<tr><td align="center">   Divisions          </td> <td align="center">   \( 4(N-2) \)      </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-3 -->
</div> <!-- cell row -->
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">// Forward substitution    </span>
<span style="color: #408080; font-style: italic">// Note that we can simplify by precalculating a[i-1]/b[i-1]</span>
  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i<span style="color: #666666">=1</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
     b[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">-</span> (a[i<span style="color: #666666">-1</span>]<span style="color: #666666">*</span>c[i<span style="color: #666666">-1</span>])<span style="color: #666666">/</span>b[i<span style="color: #666666">-1</span>];
     f[i] <span style="color: #666666">=</span> g[i] <span style="color: #666666">-</span> (a[i<span style="color: #666666">-1</span>]<span style="color: #666666">*</span>f[i<span style="color: #666666">-1</span>])<span style="color: #666666">/</span>b[i<span style="color: #666666">-1</span>];
  }
  x[n<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> f[n<span style="color: #666666">-1</span>] <span style="color: #666666">/</span> b[n<span style="color: #666666">-1</span>];
  <span style="color: #408080; font-style: italic">// Backwards substitution                                                           </span>
  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> n<span style="color: #666666">-2</span>; i <span style="color: #666666">&gt;=</span> <span style="color: #666666">0</span>; i<span style="color: #666666">--</span>) {
     f[i] <span style="color: #666666">=</span> f[i] <span style="color: #666666">-</span> c[i]<span style="color: #666666">*</span>f[i<span style="color: #666666">+1</span>]<span style="color: #666666">/</span>b[i<span style="color: #666666">+1</span>];
     x[i] <span style="color: #666666">=</span> f[i]<span style="color: #666666">/</span>b[i];
  }
</pre></div>

<h2 id="___sec19" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysics/blob/master/doc/Projects/2016/Project1/Examples/TridiagonalTiming.cpp" target="_self">The specialized Thomas algorithm (Project 1)</a>  </h2>

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>  Operation  </b></td> <td align="center"><b>Floating Point</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   Memory Reads     </td> <td align="center">   \( 6(N-2) \)      </td> </tr>
<tr><td align="center">   Memory Writes    </td> <td align="center">   \( 2(N-2) \)      </td> </tr>
<tr><td align="center">   Additions        </td> <td align="center">   \( 2(N-2) \)      </td> </tr>
<tr><td align="center">   Divisions        </td> <td align="center">   \( 2(N-2) \)      </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-3 -->
</div> <!-- cell row -->
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>      <span style="color: #408080; font-style: italic">// Forward substitution cannot be vectorized</span>
      <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">2</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) b[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span> b[i<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>d[i<span style="color: #666666">-1</span>];
      <span style="color: #408080; font-style: italic">// Backward substitution  cannot be vectorized</span>
      solution[n<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> b[n<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>d[n<span style="color: #666666">-1</span>];
      <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> n<span style="color: #666666">-2</span>; i <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>; i<span style="color: #666666">--</span>) solution[i] <span style="color: #666666">=</span> (b[i]<span style="color: #666666">+</span>solution[i<span style="color: #666666">+1</span>])<span style="color: #666666">/</span>d[i];
</pre></div>

<h2 id="___sec20" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program8.cpp" target="_self">Example: Transpose of a matrix</a> </h2>

<p>

<!-- code=text (!bc cppcode) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &quot;time.h&quot;

using namespace std; // note use of namespace
int main (int argc, char* argv[])
{
  // read in dimension of square matrix
  int n = atoi(argv[1]);
  double **A, **B;
  // Allocate space for the two matrices
  A = new double*[n]; B = new double*[n];
  for (int i = 0; i &lt; n; i++){
    A[i] = new double[n];
    B[i] = new double[n];
  }
  // Set up values for matrix A
  for (int i = 0; i &lt; n; i++){
    for (int j = 0; j &lt; n; j++) {
      A[i][j] =  cos(i*1.0)*sin(j*3.0);
    }
  }
  clock_t start, finish;
  start = clock();
  // Then compute the transpose
  for (int i = 0; i &lt; n; i++){
    for (int j = 0; j &lt; n; j++) {
      B[i][j]= A[j][i];
    }
  }

  finish = clock();
  double timeused = (double) (finish - start)/(CLOCKS_PER_SEC );
  cout &lt;&lt; setiosflags(ios::showpoint | ios::uppercase);
  cout &lt;&lt; setprecision(10) &lt;&lt; setw(20) &lt;&lt; &quot;Time used  for setting up transpose of matrix=&quot; &lt;&lt; timeused  &lt;&lt; endl;

  // Free up space
  for (int i = 0; i &lt; n; i++){
    delete[] A[i];
    delete[] B[i];
  }
  delete[] A;
  delete[] B;
  return 0;
}
</pre></div>

<h2 id="___sec21" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program9.cpp" target="_self">Matrix-matrix multiplication</a> </h2>
This the matrix-matrix multiplication code with plain c++ memory allocation. It computes at the end the Frobenius norm.

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &quot;time.h&quot;

using namespace std; // note use of namespace
int main (int argc, char* argv[])
{
  // read in dimension of square matrix
  int n = atoi(argv[1]);
  double s = 1.0/sqrt( (double) n);
  double **A, **B, **C;
  // Start timing
  clock_t start, finish;
  start = clock();
  // Allocate space for the two matrices
  A = new double*[n]; B = new double*[n]; C = new double*[n];
  for (int i = 0; i &lt; n; i++){
    A[i] = new double[n];
    B[i] = new double[n];
    C[i] = new double[n];
  }
  // Set up values for matrix A and B and zero matrix C
  for (int i = 0; i &lt; n; i++){
    for (int j = 0; j &lt; n; j++) {
      double angle = 2.0*M_PI*i*j/ (( double ) n);
      A[i][j] = s * ( sin ( angle ) + cos ( angle ) );
      B[j][i] =  A[i][j];
    }
  }
  // Then perform the matrix-matrix multiplication
  for (int i = 0; i &lt; n; i++){
    for (int j = 0; j &lt; n; j++) {
      double sum = 0.0;
       for (int k = 0; k &lt; n; k++) {
           sum += B[i][k]*A[k][j];
       }
       C[i][j] = sum;
    }
  }
  // Compute now the Frobenius norm
  double Fsum = 0.0;
  for (int i = 0; i &lt; n; i++){
    for (int j = 0; j &lt; n; j++) {
      Fsum += C[i][j]*C[i][j];
    }
  }
  Fsum = sqrt(Fsum);
  finish = clock();
  double timeused = (double) (finish - start)/(CLOCKS_PER_SEC );
  cout &lt;&lt; setiosflags(ios::showpoint | ios::uppercase);
  cout &lt;&lt; setprecision(10) &lt;&lt; setw(20) &lt;&lt; &quot;Time used  for matrix-matrix multiplication=&quot; &lt;&lt; timeused  &lt;&lt; endl;
  cout &lt;&lt; &quot;  Frobenius norm  = &quot; &lt;&lt; Fsum &lt;&lt; endl;
  // Free up space
  for (int i = 0; i &lt; n; i++){
    delete[] A[i];
    delete[] B[i];
    delete[] C[i];
  }
  delete[] A;
  delete[] B;
  delete[] C;
  return 0;
}
</pre></div>

<h2 id="___sec22" class="anchor">How do we define speedup? Simplest form </h2>

<ul>
<li> Speedup(code,sys,p) = \( T_b/T_p \)</li>
<li> Speedup measures the ratio of performance between two objects</li>
<li> Versions of same code, with different number of processors</li>
<li> Serial and vector versions</li>
<li> Try different programing languages, C++ and Fortran</li>
<li> Two algorithms computing the <b>same</b> result</li> 
</ul>

The key is choosing the correct baseline for comparison

<ul>
<li> For our serial vs. vectorization examples, using compiler-provided vectorization, the baseline is simple; the same code, with vectorization turned off</li>

<ul>
 <li> For parallel applications, this is much harder:</li>

<ul>
  <li> Choice of algorithm, decomposition, performance of baseline case etc.</li>
</ul>

</ul>

</ul>


<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._learningcpp-bs000.html">&laquo;</a></li>
  <li><a href="._learningcpp-bs000.html">1</a></li>
  <li class="active"><a href="._learningcpp-bs001.html">2</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

